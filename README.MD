# YANKI Compiler
YANKI is a modern compiler designed to transform high-level code into efficient machine code using **LLVM** as its backend. With a clean and modular architecture, YANKI provides a robust frontend featuring a **lexer**, **parser**, and **AST transformer** to generate LLVM IR.

---

## Features

- **Lexer**: Tokenizes input source code into meaningful tokens.
- **Parser**: Constructs an Abstract Syntax Tree (AST) from the token stream.
- **AST Transformer**: Converts the AST into LLVM Intermediate Representation (IR).
- **LLVM Backend**: Generates optimized machine code from LLVM IR.
- **Modular Design**: Easy to extend and maintain.

---

## File Structure 📂

```markdown
Yanki/
├── build/                  # Build directory (generated by CMake)
├── CMakeLists.txt          # CMake build configuration
├── docs/                   # Documentation and examples
│   └── start.yk            # Example YANKI source file
├── include/                # Header files
│   ├── AST/                # Abstract Syntax Tree nodes
│   │   ├── AST.hpp
│   │   └── nodes/
│   │       ├── Assignment.hpp
│   │       ├── ExitStatement.hpp
│   │       ├── Expression.hpp
│   │       ├── FloatFactor.hpp
│   │       ├── Identifier.hpp
│   │       ├── IntegerFactor.hpp
│   │       ├── Operation.hpp
│   │       ├── PrintStatement.hpp
│   │       ├── Program.hpp
│   │       ├── Statement.hpp
│   │       └── StringFactor.hpp
│   ├── Constants.hpp       # Compiler constants
│   ├── Executor/           # Code execution utilities
│   │   └── CodeExecutor.hpp
│   ├── lexer/              # Lexer components
│   ├── Lexer.hpp           # Lexer header
│   ├── parser/             # Parser components
│   │   └── Parser.hpp
│   ├── transformer/        # AST transformation utilities
│   │   └── ASTTransformer.hpp
│   ├── TypeChecker.hpp     # Type checking utilities
│   └── visitor/            # Visitor pattern utilities
│       ├── PrintVisitor.hpp
│       ├── Visitable.hpp
│       └── Visitor.hpp
├── README.md               # Project documentation
└── src/                    # Source files
    ├── AST/                # AST implementation
    │   └── nodes/
    │       ├── Assignment.cpp
    │       ├── ExitStatement.cpp
    │       ├── Expression.cpp
    │       ├── FloatFactor.cpp
    │       ├── Identifier.cpp
    │       ├── IntegerFactor.cpp
    │       ├── Operation.cpp
    │       ├── PrintStatement.cpp
    │       ├── Program.cpp
    │       ├── Statement.cpp
    │       └── StringFactor.cpp
    ├── Executor/           # Code execution implementation
    │   └── CodeExecutor.cpp
    ├── lexer/              # Lexer implementation
    ├── Lexer.cpp           # Lexer source
    ├── main.cpp            # Main compiler driver
    ├── parser/             # Parser implementation
    │   └── Parser.cpp
    ├── transformer/        # AST transformation implementation
    │   └── ASTTransformer.cpp
    ├── TypeChecker.cpp     # Type checking implementation
    └── visitor/            # Visitor pattern implementation
        └── PrintVisitor.cpp
```

## Setup 🛠️

### Prerequisites
- **LLVM** (version 14 or higher)
- **CMake** (version 3.10 or higher)
- **C++ Compiler** (supporting C++17 or higher)

### Build Instructions
1. Clone the repository:
   ```bash
   git clone https://github.com/ismaildrs/Yanki.git
   cd Yanki
   ```

2. Configure the project with CMake:
   ```bash
   mkdir build
   cd build
   cmake ..
   ```

3. Build the compiler:
   ```bash
   make
   ```

4. Run the compiler:
   ```bash
   ./yanki [input_file]
   ```
   You will get an object file called `start.o`. Use the following command to convert it into an executable:
   ```bash
   gcc -o [output_file] [input_file].o # Replace with your desired file name
   ```

### Compilation Options
1. Print Tokens:
    ```bash
    ./yanki --tokens [input_file]
    ```
2. Show AST data structure:
    ```bash
    ./yanki --ast-print [input_file]
    ```
3. Show LLVM IR:
    ```bash
    ./yanki --llvm-ir-print [input_file]
    ```

## YANKI Language Overview 📜

### Example Program 🧑‍💻

```plaintext
x: 42;
y: 3;
z: 10;

result1: x + y;
result2: z * 2;
result3: (x - z) / 2;

complex: (x + y) * (z - 5);
nested: ((x + 2) * (y - 1)) / (z + 3);

show: x;
show: result1;
show: complex;

final: x + y * z - 5;
show: final;

exit;
```
## Contributing
**⚠️ This compiler is built for learning purposes only.**

Contributions are welcome! If you would like to practice compiler-related concepts, feel free to contribute.

### How to contribute:
1. Fork the repository.
2. Create a new branch for your feature or bugfix.
3. Submit a pull request with a detailed description of your changes.
